// 基础平台通信重构 #include"comBasicPlatform.h" using namespace std; extern bool first_auth; /* 基础平台基本功能； 1. 认证连接 2. 心跳 ~ 任务下发 & 解析 & 执行 & 汇报 (指令) 3. 定时 ~ 状态上报 & 审计上报 & 异常上报 (日志) */  /* 日志（基础平台）： 	无论是状态、审计、异常，都需要与基础平台通信，并且与本地的业务执行单元沟通 	因此提供两个接口： 		1. add_log：添加记录 		2. make_json: 将记录整理为json格式，用于发送 	记录格式： 		1. Field ：字段 字段是一个包含记录生成方法的对象 一个记录可能包括其他字段或字段组 		2. 字段包含两种方法： 			1 生成JSON ：  */   /* 	定时监听线程： 	作为客户端，只能定时与平台进行主动通信，不能被动接受，因此需要构建线程进行定期交流。 	逻辑： 	1. 定时触发 	sleep(interval) 	 线程 -> exec() 	... 	2. 满足目标日期单次触发： 	sleep(interval) 		if in date not in log: 			log 			exec()  */  // 解耦： /* 1. 复用已经测试ok的内容 不做改动 以免增加开销 2. 解耦抽象的内容，可以在本地测试不依赖环境，保证正确性 3. 合理耦合，主要以下几个耦合点： 	1. 通信： posts 认证、心跳、任务分析和反馈 	CURL *curl = curl_easy_init(); 	posts 	makeUrlencodedForm 	device_auth 	device_heartbeat  	2. 业务：原来已经写好了的东西不用动，直接通过函数指针/对象调用。  */  // 定义 namespace core { 	map<string, Field*> register_fields = map<string, Field*>();// 所有字段注册于此 }  string startTime = MyDate::time2str(NULL, 3);  // 类注册宏：必须在cpp中定义 不能在.h中定义 作用是把字段注册到register_fields #ifdef _WIN32 // 在vs下可以用##连接 在g++中不能 #define ADD_FILED(name,init,value) class Field_##name##:public Field{ \ 	public:Field_##name##(string nm):Field(nm)##init##\ 	virtual Json::Value getFinalValue(Field*root)##value##\ };auto _##name## = new Field_##name##(#name); #else #define ADD_FILED(name,init,value) class Field_##name :public Field{ \ 	public:Field_##name (string nm):Field(nm) init \ 	virtual Json::Value getFinalValue(Field*root) value\ };auto _##name = new Field_##name (#name); #endif // _Win32  // 各种基础字段： 类型格式为 Field_字段名 顺序：自底向上 // 公共字段：  // 三种上报类型基本区分方法： ADD_FILED(status_type, {}, { 	root = root->getRoot();// 获取根节点 	if (root->fdname == "StateField") 		return Json::Value("basic_status"); 	if (root->fdname == "AuditField") 		return Json::Value("dvc_istce_audit_list"); 	if (root->fdname == "ErrorField") 		return Json::Value("device_instance_error_list"); 	return Json::Value(); 	}) 	// 设备编号：从配置获取 		ADD_FILED(device_instance_id, {}, { return Json::Value(enginemanager->getLocalConfig("instance_id")); })//异常用的这个 不知为何 		ADD_FILED(device_istce_id, {}, { return Json::Value(enginemanager->getLocalConfig("instance_id")); }) 		// 日志编号 : 自动生成 		ADD_FILED(log_id, {}, { return Json::Value(MyDate::log_stamp()); }) 		// 时间，默认为当前时间，如有需要再改 		ADD_FILED(time, { }, { return Json::Value(MyDate::time2str(NULL,3)); }) 		// 消息，需要自己重新修改 		ADD_FILED(message, { }, { return Json::Value("示例:使用率超过90%"); })  		//状态信息： 在获取状态信息前，需要刷新StateInfo 使用挂载函数获取 		/* 		{ 			"deploy_node_list" : 			[ 				{ 					"cpu_load" : "18.96", 					"cpu_stat" : "8  2.10GHz", 					"deploy_node_ip" : "192.168.126.28", 					"disk_space" : "175.11G: 211.46G", 					"mem_usage" : "124.91G: 125.40G" 				} 			], 			"event_produced_today" : " 1081", 			"instance_id" : "2018333011334585", 			"is_distributed" : "0", 			"loc_rule_count" : "24", 			"loc_time" : "2020-3-31 15:23:13", 			"log_handled_today" : "29684", 			"rule_checksum_client" : "8455742206823240", 			"start_time" : "2020-3-31 15:23:12", 			"status_type" : "basic_status", 			"sync_time" : "2020-3-27 17:32:9", 			"topics_born_today" : 			[ 				{ 					"topic_num" : " 1081", 					"topic_type" : "test_log_keyword" 				} 			], 			"version" : "V1.0" 		} 		*/ 		ADD_FILED(cpu_load, {}, { root->stopFlag = true; return Json::Value("示例：18.96"); })//! 		ADD_FILED(cpu_stat, {}, { return Json::Value("示例：8 2.10GHZ"); })//! 		ADD_FILED(deploy_node_ip, {}, { return Json::Value(enginemanager->getLocalConfig("node_ip")); }) 		ADD_FILED(disk_space, {}, { return Json::Value("示例:175.11G/211.46G"); })//! 		ADD_FILED(mem_usage, {}, { return Json::Value("示例:10.2G/11G"); })//! 		ADD_FILED(deploy_node_list, { 				isList = true; 				setChildren({ "cpu_load", "cpu_stat", "deploy_node_ip", "disk_space", "mem_usage" }); 			}, { return Json::Value(); })  		ADD_FILED(event_produced_today, {}, { return Json::Value("示例：1"); })//! 				ADD_FILED(instance_id, {}, { return Json::Value(enginemanager->getLocalConfig("instance_id")); }) 				ADD_FILED(is_distributed, {}, { return Json::Value("0"); })//非分布式 				ADD_FILED(loc_rule_count, {}, { return Json::Value("示例：1"); }) //! 需要计算 				ADD_FILED(loc_time, {}, { return Json::Value(MyDate::time2str(NULL,3)); }) 				ADD_FILED(log_handled_today, {}, { return Json::Value("示例：12"); })//! 				ADD_FILED(rule_checksum_client, {}, { return Json::Value("示例：12123213213"); })//! 				ADD_FILED(start_time, {}, { return Json::Value(startTime); })//引擎启动时间固定 				ADD_FILED(sync_time, {}, { return Json::Value(MyDate::getset_sync_time()); })//! 				ADD_FILED(topic_num, {}, { root->stopFlag = true; return Json::Value(0); }) 				ADD_FILED(topic_type, {}, { root->stopFlag = true; return Json::Value(enginemanager->getLocalConfig("topic_type")); }) 				ADD_FILED(topics_born_today, { isList = true; setChildren({"topic_num", "topic_type"}); }, { return Json::Value(); }) 				ADD_FILED(version, {}, { return Json::Value(enginemanager->getLocalConfig("version")); })//版本 必须要和平台一致不然会出错 所以写到配置里  				/* 				审计： 				审计发送：{ 				   "device_istce_id" : "2018333011334585", 				   "dvc_istce_audit_list" : [ 					  { 						 "device_istce_id" : "2018333011334585", 						 "event_type" : "引擎启动成功", 						 "log_id" : "158563939312005", 						 "message" : "引擎启动|用户操作", 						 "opt_type" : "引擎启动", 						 "time" : "2020-3-31 15:23:12", 						 "user" : "hw" 					  } 				   ], 				   "status_type" : "dvc_istce_audit_list" 				} 				*/  				ADD_FILED(event_type, {}, { root->stopFlag = true; return Json::Value("示例：引擎启动成功"); })//! 				// ADD_FILED(message, {}, { return Json::Value("引擎启动|用户操作"); }) 				ADD_FILED(opt_type, {}, { return Json::Value("示例：引擎启动"); })//! 				ADD_FILED(user, {}, { return Json::Value("hw"); }) 				ADD_FILED(dvc_istce_audit_list, { isList = true; setChildren({"event_type","device_istce_id","log_id","message","opt_type","time","user"}); }, { return Json::Value(""); }) 				// ADD_FILED(status_type, { isList = true; }, { return Json::Value(""); })  				ADD_FILED(error_subtype, { }, { root->stopFlag = true; return Json::Value("示例：内存"); })//! 				ADD_FILED(error_type, { }, { return Json::Value("示例：系统异常"); })//! 				ADD_FILED(risk, { }, { return Json::Value("示例：1"); })//! 				ADD_FILED(instance_error_list, { isList = true; setChildren({"device_instance_id", "error_subtype","error_type","log_id","message","opt_type","risk","time"}); }, { return Json::Value(""); })  				ADD_FILED(file_processed_num, {  }, { return Json::Value(0); })//初始化0 				ADD_FILED(alarm_num, {  }, { return Json::Value(0); }) 				ADD_FILED(process_date, {  }, { return Json::Value(MyDate::date_stamp()); })// 默认当前的日期   				// ==== 函数定义 ====  #ifdef DEBUG //回调函数  得到响应内容 int write_data(char* buffer, size_t size, size_t nmemb, void* userp) { 				std::string * str = dynamic_cast<std::string *>((std::string *)userp); 				str->append((char *)buffer, size * nmemb); 				return nmemb; 			} 			// 通信函数 			void makeUrlencodedForm(map<string, string> const & params, string * content) 			{  				content->clear(); 				map<string, string>::const_iterator it; 				for (it = params.begin(); it != params.end(); it++) 				{ 					char * key = curl_escape(it->first.c_str(), (int)it->first.size()); 					char * value = curl_escape(it->second.c_str(), (int)it->second.size()); 					*content += key; 					*content += '='; 					*content += value; 					*content += '&'; 					curl_free(key); 					curl_free(value); 				} 				if (content->back() == '&') { 					content->pop_back(); 				} 			} #endif // DEBUG   			int posts(string url, string &body, string* response) #ifdef _WIN32 			{ 				std::cout << " --- send to url --- " << url << endl << " ------------- "; 				return 0; 			} #else 				; #endif   			// 工具函数 			int str2int(string s) { 				stringstream ss; 				int ret = 0; 				ss << s; 				ss >> ret; 				return ret; 			}  			//======================== 定义 ======================  			// 引擎管理器 需要最先定义 因为其他配置从这取走 			EngineManager*enginemanager = new EngineManager();  			//全局变量定义 			ErrorLog* errorlogger = new ErrorLog(); 			AuditLog* auditlogger = new AuditLog(); 			StateLog* statelogger = new StateLog(); 			HistoryLog* historylogger = new HistoryLog();  			// 管理器 			TimerManager* timermanager = new TimerManager(); 			CoreManager* coremanager = new CoreManager();  			// curl链接 #ifndef DEBUG 			CURL *curl = curl_easy_init(); #endif // DEBUG 			// 从字段信息直接生成json 适用于列表元素的生成或者终结点 需要传入根节点 			void BaseLog::makeJsonFromField(Field*root) { 				data = makeJSON(mField, root); 			} 			Json::Value makeJSON(Field*curr, Field*root) { 				Json::Value ret; 				if (!root)root = curr; 				if (curr->isList) { // List 遍历子节点传入index以获取对应的信息 					cout << "list ~ " << endl; 					curr->index = 0; 					//this->stopFlag = false; 					//while (!this->stopFlag) { 					//} 					// 列表在makemakejson过程中只生成一次 并且不包装[] 					Json::Value tmp; 					for (auto it : curr->data) { 						tmp[it.first] = makeJSON(it.second, curr); 					} 					ret = tmp;//ret.append(tmp);  					return ret; 				} 				else if (curr->isFinal) { 					cout << "final: "; 					return curr->getFinalValue(root); 				} 				for (auto it : curr->data) { 					ret[it.first] = makeJSON(it.second, root); 				} 				return ret; 			} 			Json::Value BaseLog::recur(Field*root) { 				if (root == NULL) { // 初始化 					data = Json::Value(); 					virtualNode = map<string, BaseLog*>(); 					root = mField; 					if (!root) { 						cout << "错误！空指针！" << endl; 					} 					root->setParent(NULL); 				} 				Json::Value ret; 				if (root->isList) { 					ret.resize(0); 					virtualNode[root->fdname] = new BaseLog(root); 					Json::Value tmp; 					for (auto it : root->data) { 						it.second->setParent(root); 						tmp[it.first] = virtualNode[root->fdname]->recur(it.second);//it.second->makeJSON(root); 					} 					virtualNode[root->fdname]->data = tmp; 					return ret; 				} 				else if (root->isFinal) { 					return root->getFinalValue(root);// 获取默认值 				} 				else { 					for (auto it : root->data) { 						it.second->setParent(root); 						ret[it.first] = recur(it.second); 					} 				} 				return ret; 			}   			// 状态执行定义 			void TimerStatus::exec() { 				std::cout << "定时状态上报执行内容： 1 状态 2 审计 3 异常" << endl; 				statelogger->upload(); 				auditlogger->upload(); 				errorlogger->upload(); 			}  			// 心跳执行定义 			void TimerHeartBeat::exec() { 				this->interval.sec = str2int(enginemanager->getLocalConfig("heart_freq"));// 重置当前心跳频率 				string body; 				map<string, string> data; 				data["instance_id"] = __instance_id; 				long long int nct = MyDate::msStamp(); 				char bufTime[20]{ 0 }; 				sprintf(bufTime, "%.3f", ((float)nct) / 1000.0 - nct / 1000); 				string st = string(bufTime); 				data["loc_time"] = MyDate::get_now_time() + st.substr(st.find('.'), st.length()); 				makeUrlencodedForm(data, &body); 				std::cout << "心跳 - 发送body:" << body << endl; 				string response; 				string url = __ip + "/device_instance/heartbeat/"; 				int state_code = posts(url, body, &response); 				std::cout << "收到回复：" << response << endl; 				Json::Reader reader; 				Json::Value value; 				reader.parse(response, value); 				int code = value["code"].asInt(); 				if (value["msg"].type() == Json::stringValue) { 					response = value["msg"].asString(); 				} 				if (code == 400) {// && response=="SESSION过期，请先登录"){ 					std::cout << "重新认证后下次心跳" << state_code << endl; 					coremanager->device_auth(); 				} 				else if (code != 200) { 					std::cout << "error code" << code << endl; 					response = ""; 					//if(code!=400) 					//thread_control_fun(string("error")+"软件异常#管理服务异常#" + to_string(time(0)) + "#3#心跳失败，状态码：400"); 				} 				else {// 成功 继续处理 					string msg = response; 					if (msg == "" || msg == "暂无配置任务或策略任务" || msg == "引擎实例心跳成功" || msg.length() <= 1) { 						std::cout << "没有任务:" << msg << endl; 					} 					else if (msg == "内容失败测试") { 						Json::Value temp; 						temp["msg"] = "400 内容解析失败"; 						temp["code"] = "400"; 						coremanager->echo(temp); 					} 					else if (msg == "引擎心跳成功") { 						this->interval.sec = 1; //首次心跳成功后快速请求任务 					} 					else { 						std::cout << "接收成功" << endl; 						std::cout << "内容：" << msg << endl; 						coremanager->procTask(msg); 					} 				} 				// 同步完成 : ***time 				// cout << "定时心跳函数未挂载" << endl;// 心跳重写 			}  			// 上报历史定义 			void TimerHistory::init_time() {// 触发时间为下一天的1点 				this->interval.pm = MyDate::parseTimeStamp(time(0) + 60 * 60 * 24);//MyDate::str2time(MyDate::date_stamp(1),2) 				this->interval.pm->tm_min = 0; 				this->interval.pm->tm_sec = 0; 				this->interval.pm->tm_hour = 1;// 凌晨一点上报 			} 			void TimerHistory::exec() { 				std::cout << "到达指定时间上报执行内容：历史信息" << endl; 				historylogger->upload(); 				init_time(); 			}  			TimerManager::TimerManager() { 				// 定时管理器初始化：注册基本定时对象 这些定时对象需要在init后启动 				this->registerTimerThread("heartBeat", new TimerHeartBeat(str2int(enginemanager->getLocalConfig("heart_freq")))); 				this->registerTimerThread("status", new TimerStatus(str2int(enginemanager->getSuperConfig("state_freq"))));// TODO: 读取配置 状态上报率是超级配置 				this->registerTimerThread("history", new TimerHistory()); 			} 			// 其他定义在头文件中 过于简单不用搬到cpp 			void TimerManager::init() { 				for (auto&it : threads) { 					it.second->start(); 				} 			}  			// 只执行一次的初始化： 需要在此之前完成函数挂载 			void init_basicPlatform() { 				// 注册命令 				enginemanager->registerCommand("sleep", *(new Command_sleep())); 				enginemanager->registerCommand("wakeup", *(new Command_wakeup())); 				enginemanager->registerCommand("restart", *(new Command_restart())); 				enginemanager->registerCommand("shutdown", *(new Command_shutdown())); 				// 全局配置 				__ip = enginemanager->getLocalConfig("platformIp"); 				__instance_id = enginemanager->getLocalConfig("instance_id");  				// 启动之前先认证 				if (!coremanager->device_auth()) { 					cout << "认证失败" << endl; 					enginemanager->doCommand("shutdown"); 					return; 				} 				// 启动定时器 				timermanager->init(); 			}